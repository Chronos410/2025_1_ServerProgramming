# 2025_1_ServerProgramming<br/>

### 1주차 학습 내용: <br/>

1. 네트워크 토폴로지 이론 <br/>

    Star, Mesh, Ring, Bus등 구조와 그에 따른 장단점

2. OSI 7계층 <br/>

    OSI 7계층이 만들어진 배경과 각 계층의 역할
    

3. WAN / LAN <br/>

    WAN과 LAN의 구분


### 2주차 학습 내용: <br/>

1. OSI 참조 모델 <br/>
    각 레이어에 있는 프로토콜의 예시 <br/>
    <img src="images/2_OSI_7.png">
    
2. 프로토콜의 통신 단위 <br/>
    ethernet - Frame<br/>
    IP - Packet<br/>
    TCP - Segment<br/>
    UDP - Datagram<br/>
    HTTP - Message<br/>

3. 통신 단위들의 구조 <br/>
    이더넷 프레임의 구조는 이렇다.
    <img src="images/2_ETHERNET_FRAME_HEADER.png">

    #### MTU = 이더넷 한 프레임에 들어가는 최대 데이터 사이즈

    이더넷 페이로드는 42비트 아래로 들어오면 42비트 까지는 0으로 채워서 보낸다.<br/>

    Octets => 8비트 <br/>
    Byte 로 표기하지 않는 이유는 예전에는 1Byte가 꼭 8bit이진 않았기 떄문이다.


### 3주차 학습 내용:
휴강

### 4주차 학습 내용: <br/>

1. 물리적 주소 MAC <br/>

    MAC의 구조 <br/>

    <img src="images/3_MAC_48.png">

    EUI-48 = 48비트의 확장 고유 식별자
    xx-xx-xx-xx-xx-xx 총 6옥텟 = 48 bit <br/>
    첫 3옥텟: OUI = 제조사 번호 <br/>
    뒤의 3옥텟: NSI = 제조사가 부여한 해당 기기 일련번호 <br/>

2. powershell <br/>

    ipconfig -all <br/>
    좀 더 자세한 내 네트워크 정보

    arp -a <br/>
    지금까지 통신한 주소의 캐시 테이블을을 보기 <br/>
    IP 주소와 거기에 맵핑된 MAC 주소가 저장

    arp -d <br/>
    지금까지 통신한 주소의 캐시 테이블을 지우기 <br/>
    관리자 권한 필요
    
    ping xxx.xxx.xxx.xxx <br/>
    해당 ip로 통신을 시도해보기
    
    예시 1: <br/>
    통신할 pc의 방화벽에 아웃바운드 ICMP프로토콜이 막혔다! <br/>
    그래도 arp -a를 쳐보면 물리적 주소가 기록되는 이유는?

    ICMP를 보내기 전에 ARP프로토콜로 네트워크 전체에 해당 IP의 장비는 MAC을 내놓으라는 통신 시도를 하고, 이건 방화벽에 안막혀서 MAC는 성공적으로 가져올 수 있었음.

3. Win + R 명령어 <br/>

    ncpa.cpl = 제어판 -> 네트워크 연결

4. 데이터 전송 방식 <br/>

    point to point <br/>
    unicast, broadcast, multicast, anycast

    예시1에서 ICMP는 unicast, ARP는 broadcast 방식을 사용

    unicast = 1대1 연결 <br/>
    broadcast = 1대다 연결 <br/>
    multicast = 1대n 연결 <br/>

    broadcast 방식으로 들어오면 인터럽트가 발생하는 경우가 있다 <br/>
    왜냐? -> 일단 빨리 처리해줘야되는 패킷으로 취급하는 경우가 많기 때문(무조건은 아님)

5. 통신 방식

    * 단방향 (Simplex)          일방통행
    * 양방향 (Duplex)  
        * 반이중 (Half-Duplex)  무전기
        * 전이중 (Full-Duplex)  일반전화기

6. x86 / x64 <br/>

    램과 cpu의 대역폭이 32bit냐 64bit냐의 차이<br/>
    x64는 x86시리즈를 64비트로 확장시킨 아키텍처로 x86_64로 명명했다.

7. wireshark <br/>

    네트워크 패킷을 캡처해서 볼 수 있는 도구 <br/>
    네트워크 장비를 통하는 이더넷 프레임을 죄다 녹화해서 저장한다. <br/>
    필터링과 각 프로토콜마다 분석 기능이 있어서 재미있다. <br/>
    집에서 해봐야지.

8. Hub & Switch Hub <br/>

    #### 허브
    
    허브는 연결된 네트워크의 장비들의 통신을 죄다 브로드캐스팅으로 바꿔버림. <br/>
    딱봐도 문제가 있겠죠?

    #### 스위치 허브의 등장

    허브에 MAC 테이블을 집어넣어서 Unicast로 바꿔준다.<br/>
    네트워크 부하가 확 줄어들겠죠?<br/>
    그치만 A는 B와 C의 연결을 전혀 알 수 없어요.<br/>

    #### Managed 허브

    얘는 포트별로 MAC테이블을 사용자가 Manage 할 수 있다.<br/>

    multicast 방식으로 모든 연결을 A에게도 보내줘! 같은게 가능해서 네트워크 감시할 때 좋을 듯.

9. ARP 프로토콜 <br/>

    #### Address Resolution Protocol 주소 결정 프로토콜 <br/>
    IP 주소에 MAC 주소로 변환하는 프로토콜이다.<br/>
    BroadCast 방식으로 전 네트워크에 "이 IP 가진 사람은 자기 MAC 주소 반송해주세요"라고 요청하면 받은 사람이 MAC주소를 반송하게되고,
    이를 이더넷 프레임 헤더의 MAC Destination에 넣을 수 있다.<br/>

    #### 특성
    Ethernet통신을 시작할 때 반드시 실행된다.<br/>
    
    이더넷으로 전세계를 묶으면 부하가 미쳐날뛰겠지요?<br/>
    이 때문에 broadcast는 정책적으로 네트워크를 벗어나지 못하게 만들어서 Ethernet통신으로 묶인 네트워크를 LAN으로 정의할 수 있겠다.<br/>


### 5주차 학습 내용: <br/>

1. IP 프로토콜<br/>

    Ethernet프로토콜은 LAN이라면 IP프로토콜은 외부 네트워크과 통신 하기 위한 방식이다.<br/>

    이때 네트워크와 네트워크를 잇는 소규모 연결도 네트워크다!<br/>
    
    라우터가 주소체계를 보고 우리 네트워크에 있으면 2계층(이더넷)에서 그냥 처리함.<br/>
    근데 우리 네트워크에 없다?<br/>
    다른 네트워크에 거기서 처리해줘! 한다 <br/>
    내 네트워크를 벗어난 놈에 대해 신경을 안쓴다는 것.

    ip는 오류제어, 흐름제어, 혼잡제어 기능이 없음.


    #### 게이트웨이

    게이트웨이는 내 네트워크에 있는 "외부 네트워크와 연결된 장비"다.<br/>
    기본 게이트웨이는 하나가 디폴트로 들어가있고, 수동으로 더 추가할 수 도 있다.<br/>
    우선 순위는 route print 명령어로 볼 수 있는 라우팅 테이블 중 '활성 경로:' 에서 확인 할 수 있다. <br/>

    그래서 게이트웨이가 잘 못 설정되어있다면? <br/>
    내부 통신에는 문제가 없으나 외부 통신이 먹통이 된다!<br/>

    #### 게이트웨이가 작동하는 방법(외부로 패킷을 보내는 방법)
    
    1. 우리 네트워크에 찾는 장비가 없다.
    2. 게이트웨이에게 보낸다.
    3. 게이트웨이가 외부 네트워크로 보낸다.
    4. 첫번째 외부 네트워크에도 없다?
    5. 무 한 반 복

    들어오는 패킷에 관한 건 교수님이 나중에 알려준데<br/>

    IP프로토콜은 기본적으로 흐름제어나 부하관련한것에 신경을 안쓴다. <br/>
    대신 오류메세지정도의 정보는 돌려줄때가 있는데 이때는 ICMP 프로토콜을 사용한다. <br/>
    맞아 Ping쓰던 프로토콜이야. <br/>
    연결이 제대로 되었는지의 체크를 도와주는 프로토콜이라고 생각하자. <br/>


    #### IP의 구조 <br/>

    IP주소 이전의 네트워크 주소는 그냥 32비트짜리 쭉 이어진 주소였음.<br/>
    모든 인터넷 네트워크를 하나로 묶을 생각이였으니까.<br/>
    근데 부하가 말도안되게 걸리기 시작해서 만들어진게 IP <br/>
    기존의 주소를 역할별로 나눠서 NetworkID/HostID 로 분할해서 지정하기 시작했다.<br/>

    이때 클래스를 만들기 시작함 (Classful)<br/>
    <img src="images/5_IP_Classful.png">
    그런데 만약 내가 4개의 장비만 넣을 수 있는 네트워크를 만들려해도 C클래스, 즉 256개짜리 네트워크를 사용해야한다.<br/>

    CIDR의 등장 (Classless Inter Domain Routing)<br/>
    subnetting/supernetting을 통해서 네트워크의 크기를 자유자재로 조절 할 수 있게 되었다.
    
    이걸 위한 표기법이 추가되는데 xxx.xxx.xxx.xxx/n <- 여기에 몇비트까지 네트워크 아이디인지 적어두는 방식이 생김<br/>
    근데 이거 서브넷 마스크로 대체 가능한데 서브넷 마스크는 다음 시간에

    * IPv4 헤더의 구조
    <img src="images/5_IPv4_HEADER.png">
    
    IPv6는 Anycast 같은 통신 방식도 지원한다.<br/>
    이건 부하 조절에 쓰이는 방식이라 상위 계층에서 제어하던걸 살짝 내려서 쓴다는 느낌으로 알면 됨<br/>
    
    #### 특수 주소 <br/>

    0.0.0.0 = 내가 아닌 모든 네트워크(바깥으로 연결? 그런 느낌인듯)<br/> 
    클라이언트 입장에서는 인터넷으로의 연결 / 서버 입장에서는 모든 클라이언트와의 연결<br/>

    255.255.255.255 = BroadCasting <br/>
    게이트웨이를 벗어나지 않는 내부 네트워크에 있는 모든 장비에게 연결<br/>

    xxx.xxx.xxx.0 = 호스트 아이디가 0이면 네트워크 그 자체를 의미 <br/>
    xxx.xxx.xxx.255 = BroadCasting for xxx.xxx.xxx.~~~ <br/>

    해당 번호는 0,255 고정이 아니라 가장 적은 수, 가장 큰 수를 기반으로 함.<br/>
    예시로 서브네팅해서 0~64, 65~128로 최대치가 줄어들면 그중 가장 큰 수를 BroadCasting으로 지정함<br/>
    그래서 서브네팅으로 네트워크를 나누면 나눈만큼 * -2 개의 호스트 아이디를 저 두개에 지정해서 쓸 수 없게 된다<br/>

    127.xxx.xxx.xxx = LoofBack<br/>

    #### DLS<br/>

    DLS가 뭐냐?<br/>
    그냥 웹주소와 IP를 매칭시켜서 잔뜩 저장하고있는 서버라고 생각하자<br/>
    다음 이 시간에 계속~<br/>

    

### 6주차 학습 내용: <br/>


1. IP 프로토콜<br/>

    #### 서브넷 마스크

    <img src="images/6_SUBNET_MASK.png">

    #### 라우터(Router) <br/>
    라우터는 네트워크 경계에 있는 IP 프로토콜 장비이다.<br/>
    L3 스위치라고 볼 수 있다.

    라우터가 없으면 사설ip 네트워크 바깥으로 나갈 수 없음.

    #### 사설 주소 대역(Private address range)
    직접적으로 인터넷에 연결할 수 없는 IP로, A,B,C 클래스로 나뉨.<br/>

    왜 이렇게 만들었나? -> 나중에 합칠 일이 있으면 내부 장비들끼리 죄다 같은 아이피면 좀 그렇자너.<br/>
    즉 그냥 내부 식별용이지 큰 의미는 없음.<br/>
    
    <img src="images/6_PRIVATE_IP_RANGE.png"> <br/>
    인터넷으로 못나가는 이유는 3계층 장비에서 사설 ip는 드롭해버리기 때문.<br/>

    #### NAT
    라우터는 사설IP 장비가 보내는 통신의 헤더부분에 Source를 라우터의 주소로 바꿔줌 + 바꾼 사실을 헤더에 추가한다<br/>
    외부로 나갈때 Source는 라우터의 주소, Destination은 인터넷 주소가 되고, 들어올때는 그 반대가 된다.<br/>

    그렇게 라우터에 패킷이 들어오면(dst가 라우터 주소니까) 내부 네트워크에 Destination을 내 장비 IP로 바꿔서 집어넣어준다.<br/>

2. 방화벽 F/W<br/>

    방화벽은 랜선이 꽂힌 네트워크 인터페이스 카드(NIC)를 통하는 연결(출,입 전부)을 1차적으로 검사하고 차단한다.<br/>

    외부에서 방화벽으로 들어오는 통신을 inbound, 장비에서 외부로 내보내는 통신을 outbound로 규정하고 각자 다른 규칙으로 필터링한다.<br/>
    
    방화벽은 컴퓨터 소프트웨어로만 있는게 아니라 물리적 장비로도 있다.<br/>

3. NIC가 두개?<br/>

    NIC가 두개인 경우가 뭐가 있을까 싶지만 핸드폰의 핫스팟이 그런 경우다.<br/>
    아웃바운드 통신은 방화벽이 막는게 거의 없지만 이런 경우(어떤 NIC로 들어온 통신이 다른 NIC로 나가는 경우)에는 막히는게 좀 더 많아진다.<br/>

4. advenced IP Scanner<br/>

    네트워크에 어떤 장비가 붙어있는지 보기 쉽다.<br/>
    스캐닝이기 때문에 함부로 하면 혼난다.<br/>

    보안시스템 없는 안전한(?) 사설망에서 새 장비 추가했는데 연결이 됐나 안됐나 볼때나 쓰시오.<br/>

    xxx.xxx.xxx.0-255 같은 형식으로 필터링 가능<br/>
    xxx.xxx.0.0 - xxx.xxx.100.255 같은 방식으로도 가능<br/>

5. Filezilla

    FTP프로토콜을 사용해서 서버-클라이언트를 연결해주는 프로그램.<br/>
    주소, ID, PW, 포트를 적으면 연결을 해줘요! 와하!

6. UDP

    UDP(User Datagram Protocol)는 4계층 프로토콜로 2~3계층은 장비간 통신에 중점이 맞춰저 있다면 4계층부터는 프로그램 사이의 연결에 의미를 둔다.<br/>
    이를 위해서 포트 번호를 사용해서 프로그램을 구별한다.

    <img src="images/6_UDP_HEADER.png"> <br/>

    UDP는 가능한 데이터를 쪼개서 보내지 않는다.<br/>
    또한, IP처럼 제어기능이 없다.<br/>

    응답할 때까지 무지성으로 계속 보낸다.<br/>
    그래서 데이터를 좀 놓쳐도 상관없고, 속도가 중요한 분야에서는 써먹기 좋다.<br/>
    헤더만 봐도 가볍고 작동방식도 간단해서 빠르니까<br/>

7. VLC Player

    현존하는 거의 모든 코덱을 가지고 있는 동영상 플레이어.<br/>
    네트워크 영상을 볼 수 있는 기능이 있다!<br/>
    CCTV 영상 같은 걸 연결해서 받아볼 수 있다.<br/>
    









